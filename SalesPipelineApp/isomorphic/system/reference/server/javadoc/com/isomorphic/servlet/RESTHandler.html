<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>RESTHandler (SmartClient Enterprise Server API 14.1p (2025-06-14))</title> <meta name="date" content="2025-06-14"> <link rel="stylesheet" type="text/css" href="../../../stylesheet_custom.css" title="Style"> <script type="text/javascript" src="../../../script.js"></script> </head> <body> <script type="text/javascript">try{if(location.href.indexOf("is-external=true")==-1){parent.document.title="RESTHandler (SmartClient Enterprise Server API 14.1p (2025-06-14))"}}catch(err){}var methods={i0:10,i1:10,i2:10};var tabs={65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};var altColor="altColor";var rowColor="rowColor";var tableTab="tableTab";var activeTableTab="activeTableTab";</script> <noscript> <div>JavaScript is disabled on your browser.</div> </noscript> <div class="topNav"><a name="navbar.top"> </a> <div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div> <a name="navbar.top.firstrow"> </a> <ul class="navList" title="Navigation"> <li><a href="../../../overview-summary.html">Overview</a></li> <li><a href="package-summary.html">Package</a></li> <li class="navBarCell1Rev">Class</li> <li><a href="package-tree.html">Tree</a></li> <li><a href="../../../deprecated-list.html">Deprecated</a></li> <li><a href="../../../index-all.html">Index</a></li> <li><a href="../../../help-doc.html">Help</a></li> </ul> </div> <div class="subNav"> <ul class="navList"> <li><a href="../../../com/isomorphic/servlet/RequestContext.html" title="class in com.isomorphic.servlet"><span class="typeNameLink">Prev&nbsp;Class</span></a></li> <li><a href="../../../com/isomorphic/servlet/ScreenLoaderServlet.html" title="class in com.isomorphic.servlet"><span class="typeNameLink">Next&nbsp;Class</span></a></li> </ul> <ul class="navList"> <li><a href="../../../index.html?com/isomorphic/servlet/RESTHandler.html" target="_top">Frames</a></li> <li><a href="RESTHandler.html" target="_top">No&nbsp;Frames</a></li> </ul> <ul class="navList" id="allclasses_navbar_top"> <li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li> </ul> <div> <script type="text/javascript">allClassesLink=document.getElementById("allclasses_navbar_top");if(window==top){allClassesLink.style.display="block"}else{allClassesLink.style.display="none"};</script> </div> <div> <ul class="subNavList"> <li>Summary:&nbsp;</li> <li>Nested&nbsp;|&nbsp;</li> <li>Field&nbsp;|&nbsp;</li> <li>Constr&nbsp;|&nbsp;</li> <li><a href="#method.summary">Method</a></li> </ul> <ul class="subNavList"> <li>Detail:&nbsp;</li> <li>Field&nbsp;|&nbsp;</li> <li>Constr&nbsp;|&nbsp;</li> <li><a href="#method.detail">Method</a></li> </ul> </div> <a name="skip.navbar.top"> </a></div> <div class="header"> <div class="subTitle">com.isomorphic.servlet</div> <h2 title="Class RESTHandler" class="title">Class RESTHandler</h2> </div> <div class="contentContainer"> <ul class="inheritance"> <li>java.lang.Object</li> <li> <ul class="inheritance"> <li>HttpServlet</li> <li> <ul class="inheritance"> <li><a href="../../../com/isomorphic/servlet/BaseServlet.html" title="class in com.isomorphic.servlet">com.isomorphic.servlet.BaseServlet</a></li> <li> <ul class="inheritance"> <li>com.isomorphic.servlet.RESTHandler</li> </ul> </li> </ul> </li> </ul> </li> </ul> <div class="description"> <ul class="blockList"> <li class="blockList"> <hr> <br> <pre>public class <span class="typeNameLabel">RESTHandler</span>
extends <a href="../../../com/isomorphic/servlet/BaseServlet.html" title="class in com.isomorphic.servlet">BaseServlet</a></pre> <div class="block">This servlet handles built-in SmartClient datasource requests sent from REST clients. The <code>RestDataSource</code> provided with SmartClient is such a client, but this handler will work with any REST client that encodes its data as JSON or XML, sends its requests as POST messages and conforms to the REST transfer protocol described in the client-side documentation for <code>RestDataSource</code>. Note that you <b>must</b> read these client-side documents in order to understand how to properly format a REST request for processing by this servlet using the RestDataSource's postMessage protocol. <p> By default JSON responses will be wrapped into special markers so that code is not directly executable outside of your application. This is a preventive measure against <a href='http://forums.smartclient.com/showthread.php?t=235'>javascript hijacking</a>.<p/> The servlet accepts parameter "wrapJSONResponses": <code>true</code> - wrap JSON responses; <code>false</code> - send plain JSON reponses. The parameter can be set in your web.xml file either as a context parameter (for all servlets) or as a servlet initialization parameter. <p> If JSON wrapping is on, you can also set the prefix and suffix strings that we use to wrap responses. Again, you do this by setting the parameters "jsonPrefix" and "jsonSuffix" in your web.xml file, either as a context parameter (for all servlets) or as a servlet initialization parameter. If these parameters are not set in web.xml, they default as follows:<br><br> &nbsp;&nbsp;<b>jsonPrefix: </b>"&lt;SCRIPT&gt;//'\"]]&gt;&gt;isc_JSONResponseStart&gt;&gt;"<br> &nbsp;&nbsp;<b>jsonSuffix: </b>"//isc_JSONResponseEnd" <p> Note that these parameters can be overridden at the DataSource level, by providing a <code>.ds.xml</code> file for the DataSource, and specifying <code>jsonPrefix</code> and <code>jsonSuffix</code> in there. <p> <b>NOTE:</b> The default settings shown above are also the defaults used by the client-side RestDataSource. If you choose to change the default prefix and/or suffix strings returned by the server, you must obviously also change the strings that the client expects to see. If you are using RestDataSource, you do this by overriding the <code>jsonPrefix</code> and <code>jsonSuffix</code> properties. See the client-side documentation for details. <p> The servlet also accepts parameter "defaultDataFormat". This governs whether we expect requests to be encoded as XML or JSON, if no explicit dataFormat is provided with the request. Note that the dataFormat <b>is</b> explicitly sent with every request if you are using the Isomorphic <code>RestDataSource</code> (see below), so this parameter has no effect in that case; it is only used when no dataFormat is provided with the request, as would be the case if you are integrating with a third-party REST client. <p> If you do not specify a defaultDataFormat, "xml" is assumed. <p> The servlet also accepts parameter "dynamicDataFormatParamName". This governs the name of the dataFormat parameter we look for in incoming requests (as described above in the paragraph about "defaultDataFormat"). If you wish to send the dataFormat to use with each client request, you send an HTTP parameter with this name in the request, with a value of "xml" or "json". By default, the "dynamicDataFormatParamName" is the value used by the SmartClient RestDataSource: "isc_dataFormat". <p> NOTE: This servlet is configured to automatically set character encoding on requests and responses to UTF-8. If you wish to force a different encoding, you can do so by specifying the <code>init-param</code> "encoding" in your web.xml file, as shown in the example below. If you wish to switch off explicit encoding altogether, use the <code>init-param</code> to set a value of "none". <p> Please see the client-side documentation on Internationalization for a discussion of why this procedure is necessary. <p> This snippet shows how you might change your <code>web.xml</code> file to configure the <code>RESTHandler</code> servlet:<pre>
   &lt;servlet&gt;
       &lt;servlet-name&gt;RESTHandler&lt;/servlet-name&gt;
       &lt;servlet-class&gt;com.isomorphic.servlet.RESTHandler&lt;/servlet-class&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;defaultDataFormat&lt;/param-name&gt;
           &lt;param-value&gt;json&lt;/param-value&gt;
       &lt;/init-param&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;dynamicDataFormatParamName&lt;/param-name&gt;
           &lt;param-value&gt;theDataFormat&lt;/param-value&gt;
       &lt;/init-param&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;wrapJSONResponses&lt;/param-name&gt;
           &lt;param-value&gt;false&lt;/param-value&gt;
       &lt;/init-param&gt;
       &lt;init-param&gt;
           &lt;param-name&gt;encoding&lt;/param-name&gt;
           &lt;param-value&gt;some-other-encoding&lt;/param-value&gt;
       &lt;/init-param&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
       &lt;servlet-name&gt;RESTHandler&lt;/servlet-name&gt;
       &lt;url-pattern&gt;/restapi/&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;</pre> <p> With no additional configuration, the SmartClient server will also generate an <a target="_blank" href="https://github.com/OAI/OpenAPI-Specification">OpenAPI specification</a> describing your REST api, available at ${urlPattern}/openapi.yaml. If, for example, you've configured your servlet to respond to requests at <code>/restapi</code>, then a GET request to <code>/restapi/openapi.yaml</code> will yield the generated documentation. Refer to the client-side OpenAPI documentation topic for further discussion. Even if you do not plan to expose the generated documentation, there may be value in referring to it for fuller understanding of the remaining discussion. As it turns out, the RestDataSource postMessage protocol, or "Advanced REST", is not the only option. <P> <b>Simplified REST</b> <P> RESTHandler also offers a "Simplified REST" mode in which the DataSource name and (optionally) primary key values appear in the request URI, with simplified request and response formats. This simplified mode may be appropriate for automated systems that need to query or update DataSource data in a simplified manner. <b>Using SimplifiedREST for a SmartClient or SmartGWT browser-based UI is always, <i>always</i> wrong.</b> It will create additional work while crippling your UI's capabilities and also creating performance problems. <p> Two styles are supported. The first behaves much like the AdvancedREST protocol, in that it responds to POST requests only, makes use of request body content in all cases, and is able to support AdvancedCriteria and some batching capabilities. The second makes use of HTTP verbs and status codes more traditionally, and does none of those things. The remainder of this documentation will refer to both styles as Simplified REST, but refer to the first, more robust style as SimplifiedPOST wherever a distinction needs to be made for clarity. <P> All SimplifiedREST HTTP requests consist of the URI that you provide (including any params), the HTTP verb, and any params (key/value pairs) specified as posted data. The HTTP response format - either XML or JSON - is determined as discussed above by the servlet parameter <code>defaultDataFormat</code> or the request parameter named by the servlet parameter <code>dynamicDataFormatParamName</code>. <b>The default for SimplifiedPOST is XML</b>, as it is for the AdvancedREST postMessage protocol. <b>The default for SimplifiedREST is JSON</b>, however, amd HTTP response status codes will more precisely reflect the success (2XX) or failure (4XX/5XX) of the request. Failures will contain one or more error messages. For more details on status codes, see <a href='http://www.restapitutorial.com/lessons/httpmethods.html'>HTTP methods</a>. <P> <b>URI Interpretation</b> <P> The basic SimplifiedREST URI syntax is: <pre>
     isomorphic/RESTHandler/&lt;DataSource name&gt;[/&lt;primary key value&gt;]
 </pre> where the DataSource name must always be provided, but a primary key value is optional and in fact is not valid when using SimplifiedPOST. SimplifiedPOST requests always begin with the <code>RESTDataSource</code> prefix, but otherwise take a similar form: <pre>
     isomorphic/RESTHandler/RESTDataSource/&lt;DataSource name&gt;
 </pre> Additional field/value pairs may be provided as query parameters or posted data, including the primary key whenever the longer syntax is not used. <p> Again, SimplifiedPOST responds to the single POST verb only, and returns a uniform response format, regardless of request body content. Requests and responses are handled by other SimplifiedREST requests as follows: <ul> <li>An HTTP GET performs a fetch, with any query params beyond the primary key interpreted as simple criteria. <li>An HTTP DELETE performs a remove, with any query params or posted data beyond the primary key interpreted as simple criteria. <li>An HTTP POST performs an add, with both query params and posted data providing the record field content. <li>An HTTP PUT performs a single-row update, with both query params and posted data providing the record field content, if said field content contains a primary key value (or the operationBinding <code>providesMissingKeys</code>). A PUT with no primary key value performs an add, exactly as if it were a POST request. <li>An HTTP PATCH also performs a single-row update, with both query params and posted data providing the record field content, if said field content contains a primary key value. A PUT with no primary key value values(s) performs a multi-row update, subject to the currently configured <code>allowMultiUpdate</code> settings for updates on the target DataSource / OperationBinding. Note that direct invocation of multi-row updates is normally discouraged - see the allowMultiUpdate topic included with client documentation for further discussion, including best-practice recommendations. </ul> <P> For example, to fetch the record with primary key value <code>5</code> from <code>countryDS</code> DataSource, you would send an HTTP GET with URI <b><code>isomorphic/RESTHandler/countryDS/5</code></b>, and to add a new country record to <code>countryDS</code> DataSource, which has an autogenerated sequence primary key, you would send an HTTP POST with URI <b><code>isomorphic/RESTHandler/countryDS</code></b> and all the record field content as the POSTED data. (Various POSTED data formats, such as application/x-www-form-urlencoded "form data" are supported by the servlet.) <P> <b>Singular vs. Array Response Format</b> <P> For both XML and JSON reply formats, whether you receive a singular or array reply is determined by the HTTP request type:<ul> <li>Singular responses are sent for adds, fetches that supply the primary key value as a path segment (not as a query param or POSTED data), and updates or removes that specify the primary key either as param(s) or as a path segment. <li>Array responses are always generated for any fetch which doesn't specify the primary key as a path segment, or any update or remove request that doesn't specify a primary key.</ul> <P> So for example singular responses look like: <pre>{ fieldName : fieldValue, fieldName2: fieldValue2}</pre> for JSON, and <pre>
 &lt;record&gt;
     &lt;fieldName&gt;fieldValue&lt;/fieldName&gt;
     &lt;fieldName2&gt;fieldValue2&lt;/fieldName2&gt;
 &lt;/record&gt;</pre> for XML, whereas array responses look like: <pre>[ { fieldName : fieldValue, fieldName2: fieldValue2}, ... ]</pre> for JSON, and <pre>
 &lt;data&gt;
     &lt;record&gt;
         &lt;fieldName&gt;fieldValue&lt;/fieldName&gt;
         &lt;fieldName2&gt;fieldValue2&lt;/fieldName2&gt;
     &lt;/record&gt;
     &lt;record&gt;
         &lt;fieldName&gt;fieldValue&lt;/fieldName&gt;
         &lt;fieldName2&gt;fieldValue2&lt;/fieldName2&gt;
     &lt;/record&gt;
 &lt;/data&gt;
</pre> for XML. Note that, regardless of the above, if a request returns no results, it will be show up as an empty HTTP response with status 204 - "no content". <P> <b>Error Response Format</b> <P> When an error HTTP status (4XX or 5XX) is returned from the server, there will be an error object included. It will contain an error code and an array of error messages (even if there's just one message). For JSON, it might look like: <pre>{ code: -1, messages: ["fatal error: cannot find DataSource 'fred'"]}</pre> and for XML is might look like: <pre>
 &lt;error&gt;
     &lt;code&gt;-1&lt;/code&gt;
     &lt;messages&gt;
         &lt;message&gt;"fatal error: cannot find DataSource 'fred'"]}&lt;/message&gt;
     &lt;/messages&gt;
 &lt;/error&gt;</pre> <P> <b>Expanded URI Syntax</b> <P> In addition to the URI syntax discussed above, SimplifiedREST also accepts HTTP requests with the syntax: <pre>
     isomorphic/RESTHandler/RESTDataSource/&lt;DataSource name&gt;/&lt;operation&gt;[/&lt;operation ID&gt;]
 </pre> or <pre>
     isomorphic/RESTHandler/&lt;DataSource name&gt;/&lt;operation&gt;[/&lt;operation ID&gt;]
 </pre> where the operation is one of "add", "remove", "update", "fetch", or "custom". SimplifiedPOST requests also recognize a "batch" pseudo-operation on the path, where it accepts a batch of transactions, each having its operationType & operationId in the request body. Operation IDs on the path are optional, except of course when trying to reach a particular operationId, and for "custom" operations where it is required. For example, the URI <b><code>isomorphic/RESTHandler/countryDS/fetch/foobar</code></b> specifies that a "fetch" is to be performed with the <code>operationId</code> of "foobar". Eliminating the 'foobar' path segment would execute the default fetch operation for the countryDS DataSource. Note that support for this syntax means that you must not use these operation names as primary key values for your DataSource. <P> <b>Hybrid SimplifiedREST</b> <P> Hybrid mode allows you to send the HTTP requests as you otherwise would as described above, but receive the responses as normal RestDataSource DSResponses. To use hybrid mode, specify <code>hybridMode</code> as a servlet initialization param or query param in the HTTP request. Note that in hybrid mode, the following properties are supported as query params and/or posted data:<ul> <li><code>criteria</code> - must be valid JSON for simple or AdvancedCriteria, in the request body only <li><code>startRow</code> and <code>endRow</code> - as numbers, in either query params or request body <li><code>textMatchStyle</code> - as a string, in either query params or request body <li><code>sortBy</code> - as either a string or an array of simple <code>sortBy</code> string specifiers, in query params or request body. In case of the former, something like the following is sufficient <p> sortBy=COUNTRY&sortBy=-CUSTOMER_NAME <p> where a valid JSON array is required in case of the latter. </ul></div> </li> </ul> </div> <div class="summary"> <ul class="blockList"> <li class="blockList"> <ul class="blockList"> <li class="blockList"><a name="method.summary"> </a> <h3>Method Summary</h3> <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation"> <caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption> <tr> <th class="colFirst" scope="col">Modifier and Type</th> <th class="colLast" scope="col">Method and Description</th> </tr> <tr id="i0" class="altColor"> <td class="colFirst"><code><a href="../../../com/isomorphic/datasource/DSResponse.html" title="class in com.isomorphic.datasource">DSResponse</a></code></td> <td class="colLast"><code><span class="memberNameLink"><a href="../../../com/isomorphic/servlet/RESTHandler.html#handleDSRequest-com.isomorphic.datasource.DSRequest-com.isomorphic.rpc.RPCManager-com.isomorphic.servlet.RequestContext-">handleDSRequest</a></span>(<a href="../../../com/isomorphic/datasource/DSRequest.html" title="class in com.isomorphic.datasource">DSRequest</a>&nbsp;dsRequest, <a href="../../../com/isomorphic/rpc/RPCManager.html" title="class in com.isomorphic.rpc">RPCManager</a>&nbsp;rpc, <a href="../../../com/isomorphic/servlet/RequestContext.html" title="class in com.isomorphic.servlet">RequestContext</a>&nbsp;context)</code> <div class="block">This method is called by <a href="../../../com/isomorphic/servlet/RESTHandler.html#processRestTransaction-com.isomorphic.rpc.RPCManager-com.isomorphic.servlet.RequestContext-"><code>RESTHandler.processRestTransaction(RPCManager, RequestContext)</code></a> to handle a DSRequest sent from the client.</div> </td> </tr> <tr id="i1" class="rowColor"> <td class="colFirst"><code>void</code></td> <td class="colLast"><code><span class="memberNameLink"><a href="../../../com/isomorphic/servlet/RESTHandler.html#processRequest-HttpServletRequest-HttpServletResponse-">processRequest</a></span>(HttpServletRequest&nbsp;request, HttpServletResponse&nbsp;response)</code> <div class="block">Servlet entry point to process the request.</div> </td> </tr> <tr id="i2" class="altColor"> <td class="colFirst"><code>void</code></td> <td class="colLast"><code><span class="memberNameLink"><a href="../../../com/isomorphic/servlet/RESTHandler.html#processRestTransaction-com.isomorphic.rpc.RPCManager-com.isomorphic.servlet.RequestContext-">processRestTransaction</a></span>(<a href="../../../com/isomorphic/rpc/RPCManager.html" title="class in com.isomorphic.rpc">RPCManager</a>&nbsp;rpcManager, <a href="../../../com/isomorphic/servlet/RequestContext.html" title="class in com.isomorphic.servlet">RequestContext</a>&nbsp;context)</code> <div class="block">Process a REST transaction.</div> </td> </tr> </table> <ul class="blockList"> <li class="blockList"><a name="methods.inherited.from.class.com.isomorphic.servlet.BaseServlet"> </a> <h3>Methods inherited from class&nbsp;com.isomorphic.servlet.<a href="../../../com/isomorphic/servlet/BaseServlet.html" title="class in com.isomorphic.servlet">BaseServlet</a></h3> <code><a href="../../../com/isomorphic/servlet/BaseServlet.html#handleError-HttpServletResponse-java.lang.String-java.lang.Throwable-">handleError</a>, <a href="../../../com/isomorphic/servlet/BaseServlet.html#handleError-HttpServletResponse-java.lang.Throwable-">handleError</a></code></li> </ul> </li> </ul> </li> </ul> </div> <div class="details"> <ul class="blockList"> <li class="blockList"> <ul class="blockList"> <li class="blockList"><a name="method.detail"> </a> <h3>Method Detail</h3> <a name="processRequest-HttpServletRequest-HttpServletResponse-"> </a> <ul class="blockList"> <li class="blockList"> <h4>processRequest</h4> <pre>public&nbsp;void&nbsp;processRequest(HttpServletRequest&nbsp;request,
                           HttpServletResponse&nbsp;response)
                    throws ServletException,
                           java.io.IOException</pre> <div class="block">Servlet entry point to process the request. The default implementation instantiates an RPCManager and then invokes <a href="../../../com/isomorphic/servlet/RESTHandler.html#processRestTransaction-com.isomorphic.rpc.RPCManager-com.isomorphic.servlet.RequestContext-"><code>RESTHandler.processRestTransaction(RPCManager, RequestContext)</code></a> <br> Note, if you wish to provide customized handling, processRestTransaction() is a better override point than this method for most use cases.</div> <dl> <dt><span class="paramLabel">Parameters:</span></dt> <dd><code>request</code> - The HttpServletRequest</dd> <dd><code>response</code> - The HttpServletResponse</dd> <dt><span class="throwsLabel">Throws:</span></dt> <dd><code>ServletException</code> - As per HttpServlet.service()</dd> <dd><code>java.io.IOException</code> - As per HttpServlet.service()</dd> </dl> </li> </ul> <a name="processRestTransaction-com.isomorphic.rpc.RPCManager-com.isomorphic.servlet.RequestContext-"> </a> <ul class="blockList"> <li class="blockList"> <h4>processRestTransaction</h4> <pre>public&nbsp;void&nbsp;processRestTransaction(<a href="../../../com/isomorphic/rpc/RPCManager.html" title="class in com.isomorphic.rpc">RPCManager</a>&nbsp;rpcManager,
                                   <a href="../../../com/isomorphic/servlet/RequestContext.html" title="class in com.isomorphic.servlet">RequestContext</a>&nbsp;context)
                            throws java.lang.Exception</pre> <div class="block">Process a REST transaction. This method is called by processRequest() and iterates through each DSRequest in the transaction, executing them by calling <a href="../../../com/isomorphic/servlet/RESTHandler.html#handleDSRequest-com.isomorphic.datasource.DSRequest-com.isomorphic.rpc.RPCManager-com.isomorphic.servlet.RequestContext-"><code>RESTHandler.handleDSRequest(DSRequest, RPCManager, RequestContext)</code></a>. If you wish to provide customized REST transaction handling, this is the appropriate method to override</div> <dl> <dt><span class="paramLabel">Parameters:</span></dt> <dd><code>rpcManager</code> - The RPCManager for this REST request</dd> <dd><code>context</code> - RequestContext class provides accessors to Servlet basics like HttpServletRequest, HttpServletResponse</dd> <dt><span class="throwsLabel">Throws:</span></dt> <dd><code>java.lang.Exception</code> - For backwards compatibility this method is still declared as throwing an exception, but the default implementation traps and handles all Exceptions.</dd> </dl> </li> </ul> <a name="handleDSRequest-com.isomorphic.datasource.DSRequest-com.isomorphic.rpc.RPCManager-com.isomorphic.servlet.RequestContext-"> </a> <ul class="blockListLast"> <li class="blockList"> <h4>handleDSRequest</h4> <pre>public&nbsp;<a href="../../../com/isomorphic/datasource/DSResponse.html" title="class in com.isomorphic.datasource">DSResponse</a>&nbsp;handleDSRequest(<a href="../../../com/isomorphic/datasource/DSRequest.html" title="class in com.isomorphic.datasource">DSRequest</a>&nbsp;dsRequest,
                                  <a href="../../../com/isomorphic/rpc/RPCManager.html" title="class in com.isomorphic.rpc">RPCManager</a>&nbsp;rpc,
                                  <a href="../../../com/isomorphic/servlet/RequestContext.html" title="class in com.isomorphic.servlet">RequestContext</a>&nbsp;context)
                           throws java.lang.Exception</pre> <div class="block">This method is called by <a href="../../../com/isomorphic/servlet/RESTHandler.html#processRestTransaction-com.isomorphic.rpc.RPCManager-com.isomorphic.servlet.RequestContext-"><code>RESTHandler.processRestTransaction(RPCManager, RequestContext)</code></a> to handle a DSRequest sent from the client. This method may be called multiple times while processing a single HTTP request (if the client sent multiple requests in a batch via RPCManager.startQueue()). <p> The default implementation of this method simply calls <a href="../../../com/isomorphic/datasource/DSRequest.html#execute--"><code>DSRequest.execute()</code></a>, catching and handling any Exception by calling <a href="../../../com/isomorphic/servlet/RESTHandler.html#generateFailureResponse-com.isomorphic.datasource.DSRequest-java.lang.Exception-int-"><code>RESTHandler.generateFailureResponse(DSRequest, Exception, int)</code></a></div> <dl> <dt><span class="paramLabel">Parameters:</span></dt> <dd><code>dsRequest</code> - The DSRequest to process</dd> <dd><code>rpc</code> - The RPCManager that was used to demultiplex the DSRequest</dd> <dd><code>context</code> - RequestContext class provides accessors to Servlet basics like HttpServletRequest, HttpServletResponse</dd> <dt><span class="throwsLabel">Throws:</span></dt> <dd><code>java.lang.Exception</code> - For backwards compatibility this method is still declared as throwing an exception, but the default implementation logic (as shown above) traps and handles all Exceptions.</dd> </dl> </li> </ul> </li> </ul> </li> </ul> </div> </div> <div class="bottomNav"><a name="navbar.bottom"> </a> <div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div> <a name="navbar.bottom.firstrow"> </a> <ul class="navList" title="Navigation"> <li><a href="../../../overview-summary.html">Overview</a></li> <li><a href="package-summary.html">Package</a></li> <li class="navBarCell1Rev">Class</li> <li><a href="package-tree.html">Tree</a></li> <li><a href="../../../deprecated-list.html">Deprecated</a></li> <li><a href="../../../index-all.html">Index</a></li> <li><a href="../../../help-doc.html">Help</a></li> </ul> </div> <div class="subNav"> <ul class="navList"> <li><a href="../../../com/isomorphic/servlet/RequestContext.html" title="class in com.isomorphic.servlet"><span class="typeNameLink">Prev&nbsp;Class</span></a></li> <li><a href="../../../com/isomorphic/servlet/ScreenLoaderServlet.html" title="class in com.isomorphic.servlet"><span class="typeNameLink">Next&nbsp;Class</span></a></li> </ul> <ul class="navList"> <li><a href="../../../index.html?com/isomorphic/servlet/RESTHandler.html" target="_top">Frames</a></li> <li><a href="RESTHandler.html" target="_top">No&nbsp;Frames</a></li> </ul> <ul class="navList" id="allclasses_navbar_bottom"> <li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li> </ul> <div> <script type="text/javascript">allClassesLink=document.getElementById("allclasses_navbar_bottom");if(window==top){allClassesLink.style.display="block"}else{allClassesLink.style.display="none"};</script> </div> <div> <ul class="subNavList"> <li>Summary:&nbsp;</li> <li>Nested&nbsp;|&nbsp;</li> <li>Field&nbsp;|&nbsp;</li> <li>Constr&nbsp;|&nbsp;</li> <li><a href="#method.summary">Method</a></li> </ul> <ul class="subNavList"> <li>Detail:&nbsp;</li> <li>Field&nbsp;|&nbsp;</li> <li>Constr&nbsp;|&nbsp;</li> <li><a href="#method.detail">Method</a></li> </ul> </div> <a name="skip.navbar.bottom"> </a></div> </body> </html>